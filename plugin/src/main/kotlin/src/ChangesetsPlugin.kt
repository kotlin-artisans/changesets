/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package src

import org.gradle.api.DefaultTask
import org.gradle.api.Plugin
import org.gradle.api.Project
import org.gradle.api.tasks.Input
import org.gradle.api.tasks.TaskAction
import src.extensions.joinLines
import src.models.Changelog
import src.models.Release
import src.models.SemanticVersion
import java.time.LocalDate
import java.util.*

/**
 * A simple 'hello world' plugin.
 */
class ChangesetsPlugin : Plugin<Project> {
    override fun apply(project: Project) {
        project.tasks.register("release", ReleaseTask::class.java)
    }
}

/**
 * Manages the release of a package
 */
open class ReleaseTask : DefaultTask() {

    /**
     * Whether the task should create a commit for CHANGELOG.md changes or not.
     *
     * Defaults to true.
     */
    @Input
    val commit: Boolean = true

    @TaskAction
    fun execute() {
        val changelogFile = project.rootProject.file("CHANGELOG.md")

        val changelogLines = when (changelogFile.exists()) {
            true -> changelogFile.readLines()
            false -> arrayListOf<String>().apply {
                println("${changelogFile.name} does not exist! Creating after task execution...")
            }
        }

        val changelog = Changelog.parse(changelogLines)
        val lastReleaseVersion = when (changelog.unreleased()) {
            false -> changelog.latest().version
            true -> SemanticVersion.empty()
        }

        println(
            """
Last released version: $lastReleaseVersion

üëâ Choose one of the following options:
- major (+)
- minor (-)
- patch (~)
""".trimIndent()
        )

        val option = readln()

        val newVersion = when (option) {
            "+" -> lastReleaseVersion.incrementMajor()
            "-" -> lastReleaseVersion.incrementMinor()
            else -> lastReleaseVersion.incrementPatch()
        }

        val releaseNotes = arrayListOf<String>()

        while (true) {
            println(
                """
‚úçÔ∏è Write this version release notes (double enter to finish):
${releaseNotes.joinLines()}
""".trim()
            )

            releaseNotes.add(readln())

            if (releaseNotes.last().isEmpty()) {
                break
            }
        }

        val release = Release(
            version = newVersion,
            date = LocalDate.now(),
            notes = releaseNotes.apply {
                if (releaseNotes.size == 1) {
                    add("No release notes included in this release.")
                }
            }.filter { it.isNotEmpty() },
        )

        println(
            """
${release.version}

${release.notes.joinLines()}

ü§ö Proceed to release version? (Y/n)
        """.trimIndent()
        )

        val isToReleaseNewVersion = !readln().lowercase(Locale.getDefault()).startsWith("n")

        if (isToReleaseNewVersion) {
            changelog.include(release)
            changelogFile.writeText(changelog.toString())

            if (commit) {
                chain(
                    arrayListOf(
                        {
                            systemCall("git add ${changelogFile.path}")
                            systemCall("git commit -m \"chore(release): release notes for version $newVersion\"")
                        }
                    )
                ) {
                    it != 0
                }
            }
        }
    }

    override fun getDescription() = "Manages the release of a package"
    override fun getGroup() = "Changesets"
}

/**
 * Executes a system call via [Runtime] API, blocking the result until the process finishes.
 */
private fun systemCall(command: String) = Runtime.getRuntime().exec(
    command
).exitValue()

/**
 * Executes a chain of calls until the result of the `terminate` predicate returns true or if it reaches
 * the end of the calls list.
 */
private fun <R> chain(
    calls: List<() -> R>,
    terminate: (R) -> Boolean
): Result<Unit> {
    for (call in calls) {
        val status = call()

        if (terminate(status)) {
            return Result.failure(
                IllegalStateException("call $call failed validation with status code: $status")
            )
        }
    }

    return Result.success(Unit)
}